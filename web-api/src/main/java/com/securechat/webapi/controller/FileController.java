package com.securechat.webapi.controller;

import com.securechat.core.model.FileMetadata;
import com.securechat.webapi.service.FileDownloadService;
import com.securechat.webapi.service.FileUploadService;
import com.securechat.webapi.store.FileMetaStore;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/files")
@CrossOrigin(origins = {"http://localhost:5173", "http://localhost:3000"}, allowCredentials = "true")
public class FileController {

    public record FileAnnouncementRequest(
        String filename,
        long fileSize,
        String owner,
        String tcpHost,
        int tcpPort
    ) { }

    private final FileMetaStore fileMetaStore;
    private final FileUploadService fileUploadService;
    private final FileDownloadService fileDownloadService;

    public FileController(FileMetaStore fileMetaStore, FileUploadService fileUploadService, FileDownloadService fileDownloadService) {
        this.fileMetaStore = fileMetaStore;
        this.fileUploadService = fileUploadService;
        this.fileDownloadService = fileDownloadService;
    }

    @GetMapping
    public List<FileMetadata> getFiles() {
        return fileMetaStore.findAll();
    }

    @GetMapping("/stream")
    public SseEmitter streamFiles() {
        SseEmitter emitter = fileMetaStore.registerEmitter();
        try {
            emitter.send(SseEmitter.event().name("files-init").data(fileMetaStore.findAll()));
        } catch (IOException e) {
            emitter.completeWithError(e);
        }
        return emitter;
    }

    @PostMapping("/announce")
    public ResponseEntity<FileMetadata> announceFile(@RequestBody FileAnnouncementRequest fileMetadata) {
        // Re-create FileMetadata to ensure fileId and createdAt are generated by the server
        FileMetadata newFileMetadata = FileMetadata.create(
            fileMetadata.filename(),
            fileMetadata.fileSize(),
            fileMetadata.owner(),
            fileMetadata.tcpHost(),
            fileMetadata.tcpPort()
        );
        return ResponseEntity.ok(fileMetaStore.save(newFileMetadata));
    }

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> uploadFile(
        @RequestParam("file") MultipartFile file,
        @RequestParam("owner") String owner
    ) {
        try {
            fileUploadService.upload(file, owner);
            return ResponseEntity.accepted().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        } catch (IOException e) {
            return ResponseEntity.status(500).body("Upload failed: " + e.getMessage());
        }
    }

    @GetMapping("/{fileId}/download")
    public ResponseEntity<?> downloadFile(@PathVariable String fileId) {
        org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(FileController.class);
        log.info("Download request for fileId: {}", fileId);
        
        FileMetadata metadata = fileMetaStore.findById(fileId);
        if (metadata == null) {
            log.warn("File not found by fileId: {}, trying filename lookup", fileId);
            // Try to find by filename as fallback (in case fileId format changed)
            metadata = fileMetaStore.findByFilename(fileId);
        }
        if (metadata == null) {
            log.error("File not found: {} (total files in store: {})", fileId, fileMetaStore.findAll().size());
            return ResponseEntity.status(404).body("File not found: " + fileId);
        }

        log.info("Downloading file: {} from {}:{}", metadata.filename(), metadata.tcpHost(), metadata.tcpPort());
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            fileDownloadService.downloadFile(metadata.filename(), metadata.tcpHost(), metadata.tcpPort(), baos);
            byte[] fileData = baos.toByteArray();

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
            headers.setContentDispositionFormData("attachment", metadata.filename());
            headers.setContentLength(fileData.length);

            log.info("File download successful: {} ({} bytes)", metadata.filename(), fileData.length);
            return ResponseEntity.ok()
                .headers(headers)
                .body(fileData);
        } catch (IOException e) {
            log.error("Download failed for file: {}", metadata.filename(), e);
            return ResponseEntity.status(500).body("Download failed: " + e.getMessage());
        }
    }
}
